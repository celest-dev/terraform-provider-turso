// Code generated by ogen, DO NOT EDIT.

package tursoclient

import (
	"context"
	"net/url"
	"strings"
	"time"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/codes"
	"go.opentelemetry.io/otel/metric"
	semconv "go.opentelemetry.io/otel/semconv/v1.26.0"
	"go.opentelemetry.io/otel/trace"

	"github.com/ogen-go/ogen/conv"
	ht "github.com/ogen-go/ogen/http"
	"github.com/ogen-go/ogen/otelogen"
	"github.com/ogen-go/ogen/uri"
)

// Invoker invokes operations described by OpenAPI v3 specification.
type Invoker interface {
	// AddLocationToGroup invokes addLocationToGroup operation.
	//
	// Adds a location to the specified group.
	//
	// POST /v1/organizations/{organizationName}/groups/{groupName}/locations/{location}
	AddLocationToGroup(ctx context.Context, params AddLocationToGroupParams) (AddLocationToGroupRes, error)
	// AddOrganizationMember invokes addOrganizationMember operation.
	//
	// Add an existing Turso user to an organization.
	//
	// POST /v1/organizations/{organizationName}/members
	AddOrganizationMember(ctx context.Context, request *AddOrganizationMemberReq, params AddOrganizationMemberParams) (AddOrganizationMemberRes, error)
	// CreateAPIToken invokes createAPIToken operation.
	//
	// Returns a new API token belonging to a user.
	//
	// POST /v1/auth/api-tokens/{tokenName}
	CreateAPIToken(ctx context.Context, params CreateAPITokenParams) (jx.Raw, error)
	// CreateDatabase invokes createDatabase operation.
	//
	// Creates a new database in a group for the organization or user.
	//
	// POST /v1/organizations/{organizationName}/databases
	CreateDatabase(ctx context.Context, request *CreateDatabaseInput, params CreateDatabaseParams) (CreateDatabaseRes, error)
	// CreateDatabaseToken invokes createDatabaseToken operation.
	//
	// Generates an authorization token for the specified database.
	//
	// POST /v1/organizations/{organizationName}/databases/{databaseName}/auth/tokens
	CreateDatabaseToken(ctx context.Context, request OptCreateTokenInput, params CreateDatabaseTokenParams) (CreateDatabaseTokenRes, error)
	// CreateGroup invokes createGroup operation.
	//
	// Creates a new group for the organization or user.
	//
	// POST /v1/organizations/{organizationName}/groups
	CreateGroup(ctx context.Context, request *NewGroup, params CreateGroupParams) (CreateGroupRes, error)
	// CreateGroupToken invokes createGroupToken operation.
	//
	// Generates an authorization token for the specified group.
	//
	// POST /v1/organizations/{organizationName}/groups/{groupName}/auth/tokens
	CreateGroupToken(ctx context.Context, request OptCreateTokenInput, params CreateGroupTokenParams) (CreateGroupTokenRes, error)
	// DeleteDatabase invokes deleteDatabase operation.
	//
	// Delete a database belonging to the organization or user.
	//
	// DELETE /v1/organizations/{organizationName}/databases/{databaseName}
	DeleteDatabase(ctx context.Context, params DeleteDatabaseParams) (DeleteDatabaseRes, error)
	// DeleteGroup invokes deleteGroup operation.
	//
	// Delete a group belonging to the organization or user.
	//
	// DELETE /v1/organizations/{organizationName}/groups/{groupName}
	DeleteGroup(ctx context.Context, params DeleteGroupParams) (DeleteGroupRes, error)
	// DeleteOrganizationInviteByEmail invokes deleteOrganizationInviteByEmail operation.
	//
	// Delete an invite for the organization by email.
	//
	// DELETE /v1/organizations/{organizationName}/invites/{email}
	DeleteOrganizationInviteByEmail(ctx context.Context, params DeleteOrganizationInviteByEmailParams) (DeleteOrganizationInviteByEmailRes, error)
	// GetDatabase invokes getDatabase operation.
	//
	// Returns a database belonging to the organization or user.
	//
	// GET /v1/organizations/{organizationName}/databases/{databaseName}
	GetDatabase(ctx context.Context, params GetDatabaseParams) (GetDatabaseRes, error)
	// GetDatabaseConfiguration invokes getDatabaseConfiguration operation.
	//
	// Retrieve an individual database configuration belonging to the organization or user.
	//
	// GET /v1/organizations/{organizationName}/databases/{databaseName}/configuration
	GetDatabaseConfiguration(ctx context.Context, params GetDatabaseConfigurationParams) (*DatabaseConfigurationResponse, error)
	// GetDatabaseInstance invokes getDatabaseInstance operation.
	//
	// Return the individual database instance by name.
	//
	// GET /v1/organizations/{organizationName}/databases/{databaseName}/instances/{instanceName}
	GetDatabaseInstance(ctx context.Context, params GetDatabaseInstanceParams) (*GetDatabaseInstanceOK, error)
	// GetDatabaseStats invokes getDatabaseStats operation.
	//
	// Fetch the top queries of a database, including the count of rows read and written.
	//
	// GET /v1/organizations/{organizationName}/databases/{databaseName}/stats
	GetDatabaseStats(ctx context.Context, params GetDatabaseStatsParams) (GetDatabaseStatsRes, error)
	// GetDatabaseUsage invokes getDatabaseUsage operation.
	//
	// Fetch activity usage for a database in a given time period.
	//
	// GET /v1/organizations/{organizationName}/databases/{databaseName}/usage
	GetDatabaseUsage(ctx context.Context, params GetDatabaseUsageParams) (GetDatabaseUsageRes, error)
	// GetGroup invokes getGroup operation.
	//
	// Returns a group belonging to the organization or user.
	//
	// GET /v1/organizations/{organizationName}/groups/{groupName}
	GetGroup(ctx context.Context, params GetGroupParams) (GetGroupRes, error)
	// GetOrganizationSubscription invokes getOrganizationSubscription operation.
	//
	// Returns the current subscription details for the organization.
	//
	// GET /v1/organizations/{organizationName}/subscription
	GetOrganizationSubscription(ctx context.Context, params GetOrganizationSubscriptionParams) (*GetOrganizationSubscriptionOK, error)
	// GetOrganizationUsage invokes getOrganizationUsage operation.
	//
	// Fetch current billing cycle usage for an organization.
	//
	// GET /v1/organizations/{organizationName}/usage
	GetOrganizationUsage(ctx context.Context, params GetOrganizationUsageParams) (*GetOrganizationUsageOK, error)
	// InvalidateDatabaseTokens invokes invalidateDatabaseTokens operation.
	//
	// Invalidates all authorization tokens for the specified database.
	//
	// POST /v1/organizations/{organizationName}/databases/{databaseName}/auth/rotate
	InvalidateDatabaseTokens(ctx context.Context, params InvalidateDatabaseTokensParams) (InvalidateDatabaseTokensRes, error)
	// InvalidateGroupTokens invokes invalidateGroupTokens operation.
	//
	// Invalidates all authorization tokens for the specified group.
	//
	// POST /v1/organizations/{organizationName}/groups/{groupName}/auth/rotate
	InvalidateGroupTokens(ctx context.Context, params InvalidateGroupTokensParams) (InvalidateGroupTokensRes, error)
	// InviteOrganizationMember invokes inviteOrganizationMember operation.
	//
	// Invite a user (who isn't already a Turso user) to an organization.
	//
	// POST /v1/organizations/{organizationName}/invites
	InviteOrganizationMember(ctx context.Context, request *InviteOrganizationMemberReq, params InviteOrganizationMemberParams) (*InviteOrganizationMemberOK, error)
	// ListAPITokens invokes listAPITokens operation.
	//
	// Returns a list of API tokens belonging to a user.
	//
	// GET /v1/auth/api-tokens
	ListAPITokens(ctx context.Context) (*ListAPITokensOK, error)
	// ListDatabaseInstances invokes listDatabaseInstances operation.
	//
	// Returns a list of instances of a database. Instances are the individual primary or replica
	// databases in each region defined by the group.
	//
	// GET /v1/organizations/{organizationName}/databases/{databaseName}/instances
	ListDatabaseInstances(ctx context.Context, params ListDatabaseInstancesParams) (*ListDatabaseInstancesOK, error)
	// ListDatabases invokes listDatabases operation.
	//
	// Returns a list of databases belonging to the organization or user.
	//
	// GET /v1/organizations/{organizationName}/databases
	ListDatabases(ctx context.Context, params ListDatabasesParams) (*ListDatabasesOK, error)
	// ListGroups invokes listGroups operation.
	//
	// Returns a list of groups belonging to the organization or user.
	//
	// GET /v1/organizations/{organizationName}/groups
	ListGroups(ctx context.Context, params ListGroupsParams) (*ListGroupsOK, error)
	// ListLocations invokes listLocations operation.
	//
	// Returns a list of locations where you can create or replicate databases.
	//
	// GET /v1/locations
	ListLocations(ctx context.Context) (*ListLocationsOK, error)
	// ListOrganizationAuditLogs invokes listOrganizationAuditLogs operation.
	//
	// Return the audit logs for the given organization, ordered by the `created_at` field in descending
	// order.
	//
	// GET /v1/organizations/{organizationName}/audit-logs
	ListOrganizationAuditLogs(ctx context.Context, params ListOrganizationAuditLogsParams) (*ListOrganizationAuditLogsOK, error)
	// ListOrganizationInvites invokes listOrganizationInvites operation.
	//
	// Returns a list of invites for the organization.
	//
	// GET /v1/organizations/{organizationName}/invites
	ListOrganizationInvites(ctx context.Context, params ListOrganizationInvitesParams) (*ListOrganizationInvitesOK, error)
	// ListOrganizationInvoices invokes listOrganizationInvoices operation.
	//
	// Returns a list of invoices for the organization.
	//
	// GET /v1/organizations/{organizationName}/invoices
	ListOrganizationInvoices(ctx context.Context, params ListOrganizationInvoicesParams) (*ListOrganizationInvoicesOK, error)
	// ListOrganizationMembers invokes listOrganizationMembers operation.
	//
	// Returns a list of members part of the organization.
	//
	// GET /v1/organizations/{organizationName}/members
	ListOrganizationMembers(ctx context.Context, params ListOrganizationMembersParams) (*ListOrganizationMembersOK, error)
	// ListOrganizationPlans invokes listOrganizationPlans operation.
	//
	// Returns a list of available plans and their quotas.
	//
	// GET /v1/organizations/{organizationName}/plans
	ListOrganizationPlans(ctx context.Context, params ListOrganizationPlansParams) (*ListOrganizationPlansOK, error)
	// ListOrganizations invokes listOrganizations operation.
	//
	// Returns a list of organizations the authenticated user owns or is a member of.
	//
	// GET /v1/organizations
	ListOrganizations(ctx context.Context) ([]Organization, error)
	// RemoveLocationFromGroup invokes removeLocationFromGroup operation.
	//
	// Removes a location from the specified group.
	//
	// DELETE /v1/organizations/{organizationName}/groups/{groupName}/locations/{location}
	RemoveLocationFromGroup(ctx context.Context, params RemoveLocationFromGroupParams) (RemoveLocationFromGroupRes, error)
	// RemoveOrganizationMember invokes removeOrganizationMember operation.
	//
	// Remove a user from the organization by username.
	//
	// DELETE /v1/organizations/{organizationName}/members/{username}
	RemoveOrganizationMember(ctx context.Context, params RemoveOrganizationMemberParams) (RemoveOrganizationMemberRes, error)
	// RevokeAPIToken invokes revokeAPIToken operation.
	//
	// Revokes the provided API token belonging to a user.
	//
	// DELETE /v1/auth/api-tokens/{tokenName}
	RevokeAPIToken(ctx context.Context, params RevokeAPITokenParams) (jx.Raw, error)
	// TransferGroup invokes transferGroup operation.
	//
	// Transfer a group to another organization that you own or a member of.
	//
	// POST /v1/organizations/{organizationName}/groups/{groupName}/transfer
	TransferGroup(ctx context.Context, request *TransferGroupReq, params TransferGroupParams) (TransferGroupRes, error)
	// UnarchiveGroup invokes unarchiveGroup operation.
	//
	// Unarchive a group that has been archived due to inactivity.
	//
	// POST /v1/organizations/{organizationName}/groups/{groupName}/unarchive
	UnarchiveGroup(ctx context.Context, params UnarchiveGroupParams) (UnarchiveGroupRes, error)
	// UpdateDatabaseConfiguration invokes updateDatabaseConfiguration operation.
	//
	// Update a database configuration belonging to the organization or user.
	//
	// PATCH /v1/organizations/{organizationName}/databases/{databaseName}/configuration
	UpdateDatabaseConfiguration(ctx context.Context, request *DatabaseConfigurationInput, params UpdateDatabaseConfigurationParams) (*DatabaseConfigurationResponse, error)
	// UpdateGroupDatabases invokes updateGroupDatabases operation.
	//
	// Updates all databases in the group to the latest libSQL version.
	//
	// POST /v1/organizations/{organizationName}/groups/{groupName}/update
	UpdateGroupDatabases(ctx context.Context, params UpdateGroupDatabasesParams) (UpdateGroupDatabasesRes, error)
	// UpdateOrganization invokes updateOrganization operation.
	//
	// Update an organization you own or are a member of.
	//
	// PATCH /v1/organizations/{organizationName}
	UpdateOrganization(ctx context.Context, request *UpdateOrganizationReq, params UpdateOrganizationParams) (*UpdateOrganizationOK, error)
	// UploadDatabaseDump invokes uploadDatabaseDump operation.
	//
	// Upload a SQL dump to be used when [creating a new database](/api-reference/databases/create) from
	// seed.
	//
	// POST /v1/organizations/{organizationName}/databases/dumps
	UploadDatabaseDump(ctx context.Context, request *UploadDatabaseDumpReq, params UploadDatabaseDumpParams) (*UploadDatabaseDumpOK, error)
	// ValidateAPIToken invokes validateAPIToken operation.
	//
	// Validates an API token belonging to a user.
	//
	// GET /v1/auth/validate
	ValidateAPIToken(ctx context.Context) (*ValidateAPITokenOK, error)
}

// Client implements OAS client.
type Client struct {
	serverURL *url.URL
	baseClient
}

var _ Handler = struct {
	*Client
}{}

func trimTrailingSlashes(u *url.URL) {
	u.Path = strings.TrimRight(u.Path, "/")
	u.RawPath = strings.TrimRight(u.RawPath, "/")
}

// NewClient initializes new Client defined by OAS.
func NewClient(serverURL string, opts ...ClientOption) (*Client, error) {
	u, err := url.Parse(serverURL)
	if err != nil {
		return nil, err
	}
	trimTrailingSlashes(u)

	c, err := newClientConfig(opts...).baseClient()
	if err != nil {
		return nil, err
	}
	return &Client{
		serverURL:  u,
		baseClient: c,
	}, nil
}

type serverURLKey struct{}

// WithServerURL sets context key to override server URL.
func WithServerURL(ctx context.Context, u *url.URL) context.Context {
	return context.WithValue(ctx, serverURLKey{}, u)
}

func (c *Client) requestURL(ctx context.Context) *url.URL {
	u, ok := ctx.Value(serverURLKey{}).(*url.URL)
	if !ok {
		return c.serverURL
	}
	return u
}

// AddLocationToGroup invokes addLocationToGroup operation.
//
// Adds a location to the specified group.
//
// POST /v1/organizations/{organizationName}/groups/{groupName}/locations/{location}
func (c *Client) AddLocationToGroup(ctx context.Context, params AddLocationToGroupParams) (AddLocationToGroupRes, error) {
	res, err := c.sendAddLocationToGroup(ctx, params)
	return res, err
}

func (c *Client) sendAddLocationToGroup(ctx context.Context, params AddLocationToGroupParams) (res AddLocationToGroupRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("addLocationToGroup"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/v1/organizations/{organizationName}/groups/{groupName}/locations/{location}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AddLocationToGroup",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/v1/organizations/"
	{
		// Encode "organizationName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "organizationName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.OrganizationName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/groups/"
	{
		// Encode "groupName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "groupName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.GroupName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/locations/"
	{
		// Encode "location" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "location",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Location))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAddLocationToGroupResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AddOrganizationMember invokes addOrganizationMember operation.
//
// Add an existing Turso user to an organization.
//
// POST /v1/organizations/{organizationName}/members
func (c *Client) AddOrganizationMember(ctx context.Context, request *AddOrganizationMemberReq, params AddOrganizationMemberParams) (AddOrganizationMemberRes, error) {
	res, err := c.sendAddOrganizationMember(ctx, request, params)
	return res, err
}

func (c *Client) sendAddOrganizationMember(ctx context.Context, request *AddOrganizationMemberReq, params AddOrganizationMemberParams) (res AddOrganizationMemberRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("addOrganizationMember"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/v1/organizations/{organizationName}/members"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AddOrganizationMember",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/organizations/"
	{
		// Encode "organizationName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "organizationName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.OrganizationName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/members"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAddOrganizationMemberRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAddOrganizationMemberResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateAPIToken invokes createAPIToken operation.
//
// Returns a new API token belonging to a user.
//
// POST /v1/auth/api-tokens/{tokenName}
func (c *Client) CreateAPIToken(ctx context.Context, params CreateAPITokenParams) (jx.Raw, error) {
	res, err := c.sendCreateAPIToken(ctx, params)
	return res, err
}

func (c *Client) sendCreateAPIToken(ctx context.Context, params CreateAPITokenParams) (res jx.Raw, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("createAPIToken"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/v1/auth/api-tokens/{tokenName}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "CreateAPIToken",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/auth/api-tokens/"
	{
		// Encode "tokenName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "tokenName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.TokenName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCreateAPITokenResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateDatabase invokes createDatabase operation.
//
// Creates a new database in a group for the organization or user.
//
// POST /v1/organizations/{organizationName}/databases
func (c *Client) CreateDatabase(ctx context.Context, request *CreateDatabaseInput, params CreateDatabaseParams) (CreateDatabaseRes, error) {
	res, err := c.sendCreateDatabase(ctx, request, params)
	return res, err
}

func (c *Client) sendCreateDatabase(ctx context.Context, request *CreateDatabaseInput, params CreateDatabaseParams) (res CreateDatabaseRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("createDatabase"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/v1/organizations/{organizationName}/databases"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "CreateDatabase",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/organizations/"
	{
		// Encode "organizationName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "organizationName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.OrganizationName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/databases"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateDatabaseRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCreateDatabaseResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateDatabaseToken invokes createDatabaseToken operation.
//
// Generates an authorization token for the specified database.
//
// POST /v1/organizations/{organizationName}/databases/{databaseName}/auth/tokens
func (c *Client) CreateDatabaseToken(ctx context.Context, request OptCreateTokenInput, params CreateDatabaseTokenParams) (CreateDatabaseTokenRes, error) {
	res, err := c.sendCreateDatabaseToken(ctx, request, params)
	return res, err
}

func (c *Client) sendCreateDatabaseToken(ctx context.Context, request OptCreateTokenInput, params CreateDatabaseTokenParams) (res CreateDatabaseTokenRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("createDatabaseToken"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/v1/organizations/{organizationName}/databases/{databaseName}/auth/tokens"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "CreateDatabaseToken",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/v1/organizations/"
	{
		// Encode "organizationName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "organizationName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.OrganizationName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/databases/"
	{
		// Encode "databaseName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "databaseName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.DatabaseName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/auth/tokens"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "expiration" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "expiration",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Expiration.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "authorization" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "authorization",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Authorization.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateDatabaseTokenRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCreateDatabaseTokenResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateGroup invokes createGroup operation.
//
// Creates a new group for the organization or user.
//
// POST /v1/organizations/{organizationName}/groups
func (c *Client) CreateGroup(ctx context.Context, request *NewGroup, params CreateGroupParams) (CreateGroupRes, error) {
	res, err := c.sendCreateGroup(ctx, request, params)
	return res, err
}

func (c *Client) sendCreateGroup(ctx context.Context, request *NewGroup, params CreateGroupParams) (res CreateGroupRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("createGroup"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/v1/organizations/{organizationName}/groups"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "CreateGroup",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/organizations/"
	{
		// Encode "organizationName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "organizationName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.OrganizationName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/groups"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateGroupRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCreateGroupResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateGroupToken invokes createGroupToken operation.
//
// Generates an authorization token for the specified group.
//
// POST /v1/organizations/{organizationName}/groups/{groupName}/auth/tokens
func (c *Client) CreateGroupToken(ctx context.Context, request OptCreateTokenInput, params CreateGroupTokenParams) (CreateGroupTokenRes, error) {
	res, err := c.sendCreateGroupToken(ctx, request, params)
	return res, err
}

func (c *Client) sendCreateGroupToken(ctx context.Context, request OptCreateTokenInput, params CreateGroupTokenParams) (res CreateGroupTokenRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("createGroupToken"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/v1/organizations/{organizationName}/groups/{groupName}/auth/tokens"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "CreateGroupToken",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/v1/organizations/"
	{
		// Encode "organizationName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "organizationName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.OrganizationName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/groups/"
	{
		// Encode "groupName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "groupName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.GroupName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/auth/tokens"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "expiration" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "expiration",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Expiration.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "authorization" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "authorization",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Authorization.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateGroupTokenRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCreateGroupTokenResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteDatabase invokes deleteDatabase operation.
//
// Delete a database belonging to the organization or user.
//
// DELETE /v1/organizations/{organizationName}/databases/{databaseName}
func (c *Client) DeleteDatabase(ctx context.Context, params DeleteDatabaseParams) (DeleteDatabaseRes, error) {
	res, err := c.sendDeleteDatabase(ctx, params)
	return res, err
}

func (c *Client) sendDeleteDatabase(ctx context.Context, params DeleteDatabaseParams) (res DeleteDatabaseRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("deleteDatabase"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/v1/organizations/{organizationName}/databases/{databaseName}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DeleteDatabase",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/v1/organizations/"
	{
		// Encode "organizationName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "organizationName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.OrganizationName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/databases/"
	{
		// Encode "databaseName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "databaseName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.DatabaseName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteDatabaseResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteGroup invokes deleteGroup operation.
//
// Delete a group belonging to the organization or user.
//
// DELETE /v1/organizations/{organizationName}/groups/{groupName}
func (c *Client) DeleteGroup(ctx context.Context, params DeleteGroupParams) (DeleteGroupRes, error) {
	res, err := c.sendDeleteGroup(ctx, params)
	return res, err
}

func (c *Client) sendDeleteGroup(ctx context.Context, params DeleteGroupParams) (res DeleteGroupRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("deleteGroup"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/v1/organizations/{organizationName}/groups/{groupName}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DeleteGroup",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/v1/organizations/"
	{
		// Encode "organizationName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "organizationName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.OrganizationName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/groups/"
	{
		// Encode "groupName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "groupName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.GroupName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteGroupResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteOrganizationInviteByEmail invokes deleteOrganizationInviteByEmail operation.
//
// Delete an invite for the organization by email.
//
// DELETE /v1/organizations/{organizationName}/invites/{email}
func (c *Client) DeleteOrganizationInviteByEmail(ctx context.Context, params DeleteOrganizationInviteByEmailParams) (DeleteOrganizationInviteByEmailRes, error) {
	res, err := c.sendDeleteOrganizationInviteByEmail(ctx, params)
	return res, err
}

func (c *Client) sendDeleteOrganizationInviteByEmail(ctx context.Context, params DeleteOrganizationInviteByEmailParams) (res DeleteOrganizationInviteByEmailRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("deleteOrganizationInviteByEmail"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/v1/organizations/{organizationName}/invites/{email}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DeleteOrganizationInviteByEmail",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/v1/organizations/"
	{
		// Encode "organizationName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "organizationName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.OrganizationName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/invites/"
	{
		// Encode "email" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "email",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Email))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteOrganizationInviteByEmailResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetDatabase invokes getDatabase operation.
//
// Returns a database belonging to the organization or user.
//
// GET /v1/organizations/{organizationName}/databases/{databaseName}
func (c *Client) GetDatabase(ctx context.Context, params GetDatabaseParams) (GetDatabaseRes, error) {
	res, err := c.sendGetDatabase(ctx, params)
	return res, err
}

func (c *Client) sendGetDatabase(ctx context.Context, params GetDatabaseParams) (res GetDatabaseRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getDatabase"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/v1/organizations/{organizationName}/databases/{databaseName}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetDatabase",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/v1/organizations/"
	{
		// Encode "organizationName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "organizationName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.OrganizationName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/databases/"
	{
		// Encode "databaseName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "databaseName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.DatabaseName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetDatabaseResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetDatabaseConfiguration invokes getDatabaseConfiguration operation.
//
// Retrieve an individual database configuration belonging to the organization or user.
//
// GET /v1/organizations/{organizationName}/databases/{databaseName}/configuration
func (c *Client) GetDatabaseConfiguration(ctx context.Context, params GetDatabaseConfigurationParams) (*DatabaseConfigurationResponse, error) {
	res, err := c.sendGetDatabaseConfiguration(ctx, params)
	return res, err
}

func (c *Client) sendGetDatabaseConfiguration(ctx context.Context, params GetDatabaseConfigurationParams) (res *DatabaseConfigurationResponse, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getDatabaseConfiguration"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/v1/organizations/{organizationName}/databases/{databaseName}/configuration"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetDatabaseConfiguration",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/v1/organizations/"
	{
		// Encode "organizationName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "organizationName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.OrganizationName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/databases/"
	{
		// Encode "databaseName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "databaseName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.DatabaseName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/configuration"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetDatabaseConfigurationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetDatabaseInstance invokes getDatabaseInstance operation.
//
// Return the individual database instance by name.
//
// GET /v1/organizations/{organizationName}/databases/{databaseName}/instances/{instanceName}
func (c *Client) GetDatabaseInstance(ctx context.Context, params GetDatabaseInstanceParams) (*GetDatabaseInstanceOK, error) {
	res, err := c.sendGetDatabaseInstance(ctx, params)
	return res, err
}

func (c *Client) sendGetDatabaseInstance(ctx context.Context, params GetDatabaseInstanceParams) (res *GetDatabaseInstanceOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getDatabaseInstance"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/v1/organizations/{organizationName}/databases/{databaseName}/instances/{instanceName}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetDatabaseInstance",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/v1/organizations/"
	{
		// Encode "organizationName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "organizationName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.OrganizationName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/databases/"
	{
		// Encode "databaseName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "databaseName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.DatabaseName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/instances/"
	{
		// Encode "instanceName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "instanceName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.InstanceName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetDatabaseInstanceResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetDatabaseStats invokes getDatabaseStats operation.
//
// Fetch the top queries of a database, including the count of rows read and written.
//
// GET /v1/organizations/{organizationName}/databases/{databaseName}/stats
func (c *Client) GetDatabaseStats(ctx context.Context, params GetDatabaseStatsParams) (GetDatabaseStatsRes, error) {
	res, err := c.sendGetDatabaseStats(ctx, params)
	return res, err
}

func (c *Client) sendGetDatabaseStats(ctx context.Context, params GetDatabaseStatsParams) (res GetDatabaseStatsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getDatabaseStats"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/v1/organizations/{organizationName}/databases/{databaseName}/stats"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetDatabaseStats",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/v1/organizations/"
	{
		// Encode "organizationName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "organizationName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.OrganizationName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/databases/"
	{
		// Encode "databaseName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "databaseName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.DatabaseName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/stats"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetDatabaseStatsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetDatabaseUsage invokes getDatabaseUsage operation.
//
// Fetch activity usage for a database in a given time period.
//
// GET /v1/organizations/{organizationName}/databases/{databaseName}/usage
func (c *Client) GetDatabaseUsage(ctx context.Context, params GetDatabaseUsageParams) (GetDatabaseUsageRes, error) {
	res, err := c.sendGetDatabaseUsage(ctx, params)
	return res, err
}

func (c *Client) sendGetDatabaseUsage(ctx context.Context, params GetDatabaseUsageParams) (res GetDatabaseUsageRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getDatabaseUsage"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/v1/organizations/{organizationName}/databases/{databaseName}/usage"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetDatabaseUsage",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/v1/organizations/"
	{
		// Encode "organizationName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "organizationName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.OrganizationName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/databases/"
	{
		// Encode "databaseName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "databaseName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.DatabaseName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/usage"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "from" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "from",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.From.Get(); ok {
				return e.EncodeValue(conv.DateTimeToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "to" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "to",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.To.Get(); ok {
				return e.EncodeValue(conv.DateTimeToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetDatabaseUsageResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetGroup invokes getGroup operation.
//
// Returns a group belonging to the organization or user.
//
// GET /v1/organizations/{organizationName}/groups/{groupName}
func (c *Client) GetGroup(ctx context.Context, params GetGroupParams) (GetGroupRes, error) {
	res, err := c.sendGetGroup(ctx, params)
	return res, err
}

func (c *Client) sendGetGroup(ctx context.Context, params GetGroupParams) (res GetGroupRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getGroup"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/v1/organizations/{organizationName}/groups/{groupName}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetGroup",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/v1/organizations/"
	{
		// Encode "organizationName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "organizationName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.OrganizationName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/groups/"
	{
		// Encode "groupName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "groupName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.GroupName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetGroupResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetOrganizationSubscription invokes getOrganizationSubscription operation.
//
// Returns the current subscription details for the organization.
//
// GET /v1/organizations/{organizationName}/subscription
func (c *Client) GetOrganizationSubscription(ctx context.Context, params GetOrganizationSubscriptionParams) (*GetOrganizationSubscriptionOK, error) {
	res, err := c.sendGetOrganizationSubscription(ctx, params)
	return res, err
}

func (c *Client) sendGetOrganizationSubscription(ctx context.Context, params GetOrganizationSubscriptionParams) (res *GetOrganizationSubscriptionOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getOrganizationSubscription"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/v1/organizations/{organizationName}/subscription"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetOrganizationSubscription",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/organizations/"
	{
		// Encode "organizationName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "organizationName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.OrganizationName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/subscription"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetOrganizationSubscriptionResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetOrganizationUsage invokes getOrganizationUsage operation.
//
// Fetch current billing cycle usage for an organization.
//
// GET /v1/organizations/{organizationName}/usage
func (c *Client) GetOrganizationUsage(ctx context.Context, params GetOrganizationUsageParams) (*GetOrganizationUsageOK, error) {
	res, err := c.sendGetOrganizationUsage(ctx, params)
	return res, err
}

func (c *Client) sendGetOrganizationUsage(ctx context.Context, params GetOrganizationUsageParams) (res *GetOrganizationUsageOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getOrganizationUsage"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/v1/organizations/{organizationName}/usage"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetOrganizationUsage",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/organizations/"
	{
		// Encode "organizationName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "organizationName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.OrganizationName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/usage"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetOrganizationUsageResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// InvalidateDatabaseTokens invokes invalidateDatabaseTokens operation.
//
// Invalidates all authorization tokens for the specified database.
//
// POST /v1/organizations/{organizationName}/databases/{databaseName}/auth/rotate
func (c *Client) InvalidateDatabaseTokens(ctx context.Context, params InvalidateDatabaseTokensParams) (InvalidateDatabaseTokensRes, error) {
	res, err := c.sendInvalidateDatabaseTokens(ctx, params)
	return res, err
}

func (c *Client) sendInvalidateDatabaseTokens(ctx context.Context, params InvalidateDatabaseTokensParams) (res InvalidateDatabaseTokensRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("invalidateDatabaseTokens"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/v1/organizations/{organizationName}/databases/{databaseName}/auth/rotate"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "InvalidateDatabaseTokens",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/v1/organizations/"
	{
		// Encode "organizationName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "organizationName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.OrganizationName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/databases/"
	{
		// Encode "databaseName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "databaseName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.DatabaseName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/auth/rotate"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeInvalidateDatabaseTokensResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// InvalidateGroupTokens invokes invalidateGroupTokens operation.
//
// Invalidates all authorization tokens for the specified group.
//
// POST /v1/organizations/{organizationName}/groups/{groupName}/auth/rotate
func (c *Client) InvalidateGroupTokens(ctx context.Context, params InvalidateGroupTokensParams) (InvalidateGroupTokensRes, error) {
	res, err := c.sendInvalidateGroupTokens(ctx, params)
	return res, err
}

func (c *Client) sendInvalidateGroupTokens(ctx context.Context, params InvalidateGroupTokensParams) (res InvalidateGroupTokensRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("invalidateGroupTokens"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/v1/organizations/{organizationName}/groups/{groupName}/auth/rotate"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "InvalidateGroupTokens",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/v1/organizations/"
	{
		// Encode "organizationName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "organizationName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.OrganizationName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/groups/"
	{
		// Encode "groupName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "groupName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.GroupName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/auth/rotate"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeInvalidateGroupTokensResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// InviteOrganizationMember invokes inviteOrganizationMember operation.
//
// Invite a user (who isn't already a Turso user) to an organization.
//
// POST /v1/organizations/{organizationName}/invites
func (c *Client) InviteOrganizationMember(ctx context.Context, request *InviteOrganizationMemberReq, params InviteOrganizationMemberParams) (*InviteOrganizationMemberOK, error) {
	res, err := c.sendInviteOrganizationMember(ctx, request, params)
	return res, err
}

func (c *Client) sendInviteOrganizationMember(ctx context.Context, request *InviteOrganizationMemberReq, params InviteOrganizationMemberParams) (res *InviteOrganizationMemberOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("inviteOrganizationMember"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/v1/organizations/{organizationName}/invites"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "InviteOrganizationMember",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/organizations/"
	{
		// Encode "organizationName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "organizationName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.OrganizationName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/invites"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeInviteOrganizationMemberRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeInviteOrganizationMemberResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListAPITokens invokes listAPITokens operation.
//
// Returns a list of API tokens belonging to a user.
//
// GET /v1/auth/api-tokens
func (c *Client) ListAPITokens(ctx context.Context) (*ListAPITokensOK, error) {
	res, err := c.sendListAPITokens(ctx)
	return res, err
}

func (c *Client) sendListAPITokens(ctx context.Context) (res *ListAPITokensOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listAPITokens"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/v1/auth/api-tokens"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ListAPITokens",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/auth/api-tokens"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeListAPITokensResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListDatabaseInstances invokes listDatabaseInstances operation.
//
// Returns a list of instances of a database. Instances are the individual primary or replica
// databases in each region defined by the group.
//
// GET /v1/organizations/{organizationName}/databases/{databaseName}/instances
func (c *Client) ListDatabaseInstances(ctx context.Context, params ListDatabaseInstancesParams) (*ListDatabaseInstancesOK, error) {
	res, err := c.sendListDatabaseInstances(ctx, params)
	return res, err
}

func (c *Client) sendListDatabaseInstances(ctx context.Context, params ListDatabaseInstancesParams) (res *ListDatabaseInstancesOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listDatabaseInstances"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/v1/organizations/{organizationName}/databases/{databaseName}/instances"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ListDatabaseInstances",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/v1/organizations/"
	{
		// Encode "organizationName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "organizationName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.OrganizationName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/databases/"
	{
		// Encode "databaseName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "databaseName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.DatabaseName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/instances"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeListDatabaseInstancesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListDatabases invokes listDatabases operation.
//
// Returns a list of databases belonging to the organization or user.
//
// GET /v1/organizations/{organizationName}/databases
func (c *Client) ListDatabases(ctx context.Context, params ListDatabasesParams) (*ListDatabasesOK, error) {
	res, err := c.sendListDatabases(ctx, params)
	return res, err
}

func (c *Client) sendListDatabases(ctx context.Context, params ListDatabasesParams) (res *ListDatabasesOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listDatabases"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/v1/organizations/{organizationName}/databases"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ListDatabases",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/organizations/"
	{
		// Encode "organizationName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "organizationName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.OrganizationName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/databases"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "group" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "group",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Group.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "schema" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "schema",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Schema.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeListDatabasesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListGroups invokes listGroups operation.
//
// Returns a list of groups belonging to the organization or user.
//
// GET /v1/organizations/{organizationName}/groups
func (c *Client) ListGroups(ctx context.Context, params ListGroupsParams) (*ListGroupsOK, error) {
	res, err := c.sendListGroups(ctx, params)
	return res, err
}

func (c *Client) sendListGroups(ctx context.Context, params ListGroupsParams) (res *ListGroupsOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listGroups"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/v1/organizations/{organizationName}/groups"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ListGroups",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/organizations/"
	{
		// Encode "organizationName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "organizationName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.OrganizationName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/groups"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeListGroupsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListLocations invokes listLocations operation.
//
// Returns a list of locations where you can create or replicate databases.
//
// GET /v1/locations
func (c *Client) ListLocations(ctx context.Context) (*ListLocationsOK, error) {
	res, err := c.sendListLocations(ctx)
	return res, err
}

func (c *Client) sendListLocations(ctx context.Context) (res *ListLocationsOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listLocations"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/v1/locations"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ListLocations",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/locations"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeListLocationsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListOrganizationAuditLogs invokes listOrganizationAuditLogs operation.
//
// Return the audit logs for the given organization, ordered by the `created_at` field in descending
// order.
//
// GET /v1/organizations/{organizationName}/audit-logs
func (c *Client) ListOrganizationAuditLogs(ctx context.Context, params ListOrganizationAuditLogsParams) (*ListOrganizationAuditLogsOK, error) {
	res, err := c.sendListOrganizationAuditLogs(ctx, params)
	return res, err
}

func (c *Client) sendListOrganizationAuditLogs(ctx context.Context, params ListOrganizationAuditLogsParams) (res *ListOrganizationAuditLogsOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listOrganizationAuditLogs"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/v1/organizations/{organizationName}/audit-logs"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ListOrganizationAuditLogs",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/organizations/"
	{
		// Encode "organizationName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "organizationName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.OrganizationName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/audit-logs"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "page_size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page_size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeListOrganizationAuditLogsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListOrganizationInvites invokes listOrganizationInvites operation.
//
// Returns a list of invites for the organization.
//
// GET /v1/organizations/{organizationName}/invites
func (c *Client) ListOrganizationInvites(ctx context.Context, params ListOrganizationInvitesParams) (*ListOrganizationInvitesOK, error) {
	res, err := c.sendListOrganizationInvites(ctx, params)
	return res, err
}

func (c *Client) sendListOrganizationInvites(ctx context.Context, params ListOrganizationInvitesParams) (res *ListOrganizationInvitesOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listOrganizationInvites"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/v1/organizations/{organizationName}/invites"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ListOrganizationInvites",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/organizations/"
	{
		// Encode "organizationName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "organizationName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.OrganizationName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/invites"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeListOrganizationInvitesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListOrganizationInvoices invokes listOrganizationInvoices operation.
//
// Returns a list of invoices for the organization.
//
// GET /v1/organizations/{organizationName}/invoices
func (c *Client) ListOrganizationInvoices(ctx context.Context, params ListOrganizationInvoicesParams) (*ListOrganizationInvoicesOK, error) {
	res, err := c.sendListOrganizationInvoices(ctx, params)
	return res, err
}

func (c *Client) sendListOrganizationInvoices(ctx context.Context, params ListOrganizationInvoicesParams) (res *ListOrganizationInvoicesOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listOrganizationInvoices"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/v1/organizations/{organizationName}/invoices"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ListOrganizationInvoices",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/organizations/"
	{
		// Encode "organizationName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "organizationName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.OrganizationName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/invoices"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "type" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Type.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeListOrganizationInvoicesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListOrganizationMembers invokes listOrganizationMembers operation.
//
// Returns a list of members part of the organization.
//
// GET /v1/organizations/{organizationName}/members
func (c *Client) ListOrganizationMembers(ctx context.Context, params ListOrganizationMembersParams) (*ListOrganizationMembersOK, error) {
	res, err := c.sendListOrganizationMembers(ctx, params)
	return res, err
}

func (c *Client) sendListOrganizationMembers(ctx context.Context, params ListOrganizationMembersParams) (res *ListOrganizationMembersOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listOrganizationMembers"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/v1/organizations/{organizationName}/members"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ListOrganizationMembers",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/organizations/"
	{
		// Encode "organizationName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "organizationName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.OrganizationName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/members"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeListOrganizationMembersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListOrganizationPlans invokes listOrganizationPlans operation.
//
// Returns a list of available plans and their quotas.
//
// GET /v1/organizations/{organizationName}/plans
func (c *Client) ListOrganizationPlans(ctx context.Context, params ListOrganizationPlansParams) (*ListOrganizationPlansOK, error) {
	res, err := c.sendListOrganizationPlans(ctx, params)
	return res, err
}

func (c *Client) sendListOrganizationPlans(ctx context.Context, params ListOrganizationPlansParams) (res *ListOrganizationPlansOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listOrganizationPlans"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/v1/organizations/{organizationName}/plans"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ListOrganizationPlans",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/organizations/"
	{
		// Encode "organizationName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "organizationName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.OrganizationName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/plans"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeListOrganizationPlansResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListOrganizations invokes listOrganizations operation.
//
// Returns a list of organizations the authenticated user owns or is a member of.
//
// GET /v1/organizations
func (c *Client) ListOrganizations(ctx context.Context) ([]Organization, error) {
	res, err := c.sendListOrganizations(ctx)
	return res, err
}

func (c *Client) sendListOrganizations(ctx context.Context) (res []Organization, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listOrganizations"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/v1/organizations"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ListOrganizations",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/organizations"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeListOrganizationsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// RemoveLocationFromGroup invokes removeLocationFromGroup operation.
//
// Removes a location from the specified group.
//
// DELETE /v1/organizations/{organizationName}/groups/{groupName}/locations/{location}
func (c *Client) RemoveLocationFromGroup(ctx context.Context, params RemoveLocationFromGroupParams) (RemoveLocationFromGroupRes, error) {
	res, err := c.sendRemoveLocationFromGroup(ctx, params)
	return res, err
}

func (c *Client) sendRemoveLocationFromGroup(ctx context.Context, params RemoveLocationFromGroupParams) (res RemoveLocationFromGroupRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("removeLocationFromGroup"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/v1/organizations/{organizationName}/groups/{groupName}/locations/{location}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "RemoveLocationFromGroup",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/v1/organizations/"
	{
		// Encode "organizationName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "organizationName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.OrganizationName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/groups/"
	{
		// Encode "groupName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "groupName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.GroupName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/locations/"
	{
		// Encode "location" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "location",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Location))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeRemoveLocationFromGroupResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// RemoveOrganizationMember invokes removeOrganizationMember operation.
//
// Remove a user from the organization by username.
//
// DELETE /v1/organizations/{organizationName}/members/{username}
func (c *Client) RemoveOrganizationMember(ctx context.Context, params RemoveOrganizationMemberParams) (RemoveOrganizationMemberRes, error) {
	res, err := c.sendRemoveOrganizationMember(ctx, params)
	return res, err
}

func (c *Client) sendRemoveOrganizationMember(ctx context.Context, params RemoveOrganizationMemberParams) (res RemoveOrganizationMemberRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("removeOrganizationMember"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/v1/organizations/{organizationName}/members/{username}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "RemoveOrganizationMember",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/v1/organizations/"
	{
		// Encode "organizationName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "organizationName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.OrganizationName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/members/"
	{
		// Encode "username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Username))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeRemoveOrganizationMemberResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// RevokeAPIToken invokes revokeAPIToken operation.
//
// Revokes the provided API token belonging to a user.
//
// DELETE /v1/auth/api-tokens/{tokenName}
func (c *Client) RevokeAPIToken(ctx context.Context, params RevokeAPITokenParams) (jx.Raw, error) {
	res, err := c.sendRevokeAPIToken(ctx, params)
	return res, err
}

func (c *Client) sendRevokeAPIToken(ctx context.Context, params RevokeAPITokenParams) (res jx.Raw, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("revokeAPIToken"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/v1/auth/api-tokens/{tokenName}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "RevokeAPIToken",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/auth/api-tokens/"
	{
		// Encode "tokenName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "tokenName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.TokenName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeRevokeAPITokenResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TransferGroup invokes transferGroup operation.
//
// Transfer a group to another organization that you own or a member of.
//
// POST /v1/organizations/{organizationName}/groups/{groupName}/transfer
func (c *Client) TransferGroup(ctx context.Context, request *TransferGroupReq, params TransferGroupParams) (TransferGroupRes, error) {
	res, err := c.sendTransferGroup(ctx, request, params)
	return res, err
}

func (c *Client) sendTransferGroup(ctx context.Context, request *TransferGroupReq, params TransferGroupParams) (res TransferGroupRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("transferGroup"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/v1/organizations/{organizationName}/groups/{groupName}/transfer"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "TransferGroup",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/v1/organizations/"
	{
		// Encode "organizationName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "organizationName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.OrganizationName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/groups/"
	{
		// Encode "groupName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "groupName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.GroupName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/transfer"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeTransferGroupRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeTransferGroupResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UnarchiveGroup invokes unarchiveGroup operation.
//
// Unarchive a group that has been archived due to inactivity.
//
// POST /v1/organizations/{organizationName}/groups/{groupName}/unarchive
func (c *Client) UnarchiveGroup(ctx context.Context, params UnarchiveGroupParams) (UnarchiveGroupRes, error) {
	res, err := c.sendUnarchiveGroup(ctx, params)
	return res, err
}

func (c *Client) sendUnarchiveGroup(ctx context.Context, params UnarchiveGroupParams) (res UnarchiveGroupRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("unarchiveGroup"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/v1/organizations/{organizationName}/groups/{groupName}/unarchive"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "UnarchiveGroup",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/v1/organizations/"
	{
		// Encode "organizationName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "organizationName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.OrganizationName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/groups/"
	{
		// Encode "groupName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "groupName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.GroupName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/unarchive"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUnarchiveGroupResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateDatabaseConfiguration invokes updateDatabaseConfiguration operation.
//
// Update a database configuration belonging to the organization or user.
//
// PATCH /v1/organizations/{organizationName}/databases/{databaseName}/configuration
func (c *Client) UpdateDatabaseConfiguration(ctx context.Context, request *DatabaseConfigurationInput, params UpdateDatabaseConfigurationParams) (*DatabaseConfigurationResponse, error) {
	res, err := c.sendUpdateDatabaseConfiguration(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateDatabaseConfiguration(ctx context.Context, request *DatabaseConfigurationInput, params UpdateDatabaseConfigurationParams) (res *DatabaseConfigurationResponse, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("updateDatabaseConfiguration"),
		semconv.HTTPRequestMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/v1/organizations/{organizationName}/databases/{databaseName}/configuration"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "UpdateDatabaseConfiguration",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/v1/organizations/"
	{
		// Encode "organizationName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "organizationName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.OrganizationName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/databases/"
	{
		// Encode "databaseName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "databaseName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.DatabaseName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/configuration"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateDatabaseConfigurationRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUpdateDatabaseConfigurationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateGroupDatabases invokes updateGroupDatabases operation.
//
// Updates all databases in the group to the latest libSQL version.
//
// POST /v1/organizations/{organizationName}/groups/{groupName}/update
func (c *Client) UpdateGroupDatabases(ctx context.Context, params UpdateGroupDatabasesParams) (UpdateGroupDatabasesRes, error) {
	res, err := c.sendUpdateGroupDatabases(ctx, params)
	return res, err
}

func (c *Client) sendUpdateGroupDatabases(ctx context.Context, params UpdateGroupDatabasesParams) (res UpdateGroupDatabasesRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("updateGroupDatabases"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/v1/organizations/{organizationName}/groups/{groupName}/update"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "UpdateGroupDatabases",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/v1/organizations/"
	{
		// Encode "organizationName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "organizationName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.OrganizationName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/groups/"
	{
		// Encode "groupName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "groupName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.GroupName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/update"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUpdateGroupDatabasesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateOrganization invokes updateOrganization operation.
//
// Update an organization you own or are a member of.
//
// PATCH /v1/organizations/{organizationName}
func (c *Client) UpdateOrganization(ctx context.Context, request *UpdateOrganizationReq, params UpdateOrganizationParams) (*UpdateOrganizationOK, error) {
	res, err := c.sendUpdateOrganization(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateOrganization(ctx context.Context, request *UpdateOrganizationReq, params UpdateOrganizationParams) (res *UpdateOrganizationOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("updateOrganization"),
		semconv.HTTPRequestMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/v1/organizations/{organizationName}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "UpdateOrganization",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/organizations/"
	{
		// Encode "organizationName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "organizationName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.OrganizationName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateOrganizationRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUpdateOrganizationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UploadDatabaseDump invokes uploadDatabaseDump operation.
//
// Upload a SQL dump to be used when [creating a new database](/api-reference/databases/create) from
// seed.
//
// POST /v1/organizations/{organizationName}/databases/dumps
func (c *Client) UploadDatabaseDump(ctx context.Context, request *UploadDatabaseDumpReq, params UploadDatabaseDumpParams) (*UploadDatabaseDumpOK, error) {
	res, err := c.sendUploadDatabaseDump(ctx, request, params)
	return res, err
}

func (c *Client) sendUploadDatabaseDump(ctx context.Context, request *UploadDatabaseDumpReq, params UploadDatabaseDumpParams) (res *UploadDatabaseDumpOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("uploadDatabaseDump"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/v1/organizations/{organizationName}/databases/dumps"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "UploadDatabaseDump",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/organizations/"
	{
		// Encode "organizationName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "organizationName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.OrganizationName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/databases/dumps"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUploadDatabaseDumpRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUploadDatabaseDumpResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ValidateAPIToken invokes validateAPIToken operation.
//
// Validates an API token belonging to a user.
//
// GET /v1/auth/validate
func (c *Client) ValidateAPIToken(ctx context.Context) (*ValidateAPITokenOK, error) {
	res, err := c.sendValidateAPIToken(ctx)
	return res, err
}

func (c *Client) sendValidateAPIToken(ctx context.Context) (res *ValidateAPITokenOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("validateAPIToken"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/v1/auth/validate"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ValidateAPIToken",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/auth/validate"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeValidateAPITokenResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}
